<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-10-28 Fri 22:38 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Getting Started with OpenBuildNet</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Truong X. Nghiem" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Getting Started with OpenBuildNet
<br>
<span class="subtitle">Docker-based Distribution</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. Introduction</a></li>
<li><a href="#orgheadline8">2. Installation</a>
<ul>
<li><a href="#orgheadline2">2.1. Prerequisites</a></li>
<li><a href="#orgheadline3">2.2. Docker installation</a></li>
<li><a href="#orgheadline5">2.3. Pull the Docker images of OpenBuildNet</a></li>
<li><a href="#orgheadline7">2.4. MQTT Broker</a>
<ul>
<li><a href="#orgheadline6">2.4.1. Using the built-in MQTT broker</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline12">3. Overview of OpenBuildNet Architecture</a>
<ul>
<li><a href="#orgheadline9">3.1. Nodes as the Building Blocks</a></li>
<li><a href="#orgheadline10">3.2. Distributed Network of Nodes</a></li>
<li><a href="#orgheadline11">3.3. Execution and Synchronization</a></li>
</ul>
</li>
<li><a href="#orgheadline25">4. Tutorial: Control System Simulation</a>
<ul>
<li><a href="#orgheadline13">4.1. The control system</a></li>
<li><a href="#orgheadline14">4.2. Design of the OpenBuildNet simulation</a></li>
<li><a href="#orgheadline15">4.3. The setpoint node</a></li>
<li><a href="#orgheadline16">4.4. The plant node</a></li>
<li><a href="#orgheadline17">4.5. The controller node</a></li>
<li><a href="#orgheadline23">4.6. The simulation script</a>
<ul>
<li><a href="#orgheadline18">4.6.1. Simulation setttings</a></li>
<li><a href="#orgheadline19">4.6.2. Node declarations</a></li>
<li><a href="#orgheadline20">4.6.3. Port connections</a></li>
<li><a href="#orgheadline21">4.6.4. Model export</a></li>
<li><a href="#orgheadline22">4.6.5. Final matter</a></li>
</ul>
</li>
<li><a href="#orgheadline24">4.7. Running the simulation</a></li>
</ul>
</li>
<li><a href="#orgheadline26">5. Notes on simulation performance</a></li>
<li><a href="#orgheadline27">6. Developing nodes with OpenBuildNet Docker images</a></li>
<li><a href="#orgheadline28">7. Customize OpenBuildNet Docker Images</a></li>
<li><a href="#orgheadline4">8. Appendix</a>
<ul>
<li><a href="#orgheadline29">8.1. Prebuilt Docker images of OpenBuildNet</a></li>
<li><a href="#orgheadline30">8.2. Applications of OpenBuildNet Docker-based distribution</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
OpenBuildNet is an open-source framework for distributed co-simulation, where specialized and sophisticated simulation tools in various fields are incorporated in a common platform to study the interdependencies between the subsystems.
The main goal of OpenBuildNet is to provide a <i>framework and software tools for large-scale distributed co-simulation of complex systems</i>, with <i>intended applications in smart energy systems</i> such as smart buildings, power grids, and optimization-based controllers.
Most of the time, such co-simulation systems are heterogeneous, which involves subsystems of different types and on potentially vastly different time scales.
For example, a smart grid simulation may contain buildings, which have very slow thermal dynamics and fast electrical system dynamics, and the power grid with a very fast sub-second time scale.
Furthermore, subsystems come in different forms and sizes: from large and highly sophisticated simulators such as EnergyPlus, to moderately complex controllers prototyped in Matlab or Python, to simple rule-based controllers implemented in C.
OpenBuildNet aims to support simulation systems composed of many heterogeneous sub-simulators distributed over multiple networked computers.
It allows integration of specialized or legacy tools into the co-simulation to lower the barrier for adoption and reuse their industrial-strength, highly developed functionality.
</p>

<p>
OpenBuildNet targets  researchers and engineers in control, optimization, and computer science, who wish to apply their expertise and techniques to smart energy systems.
With OpenBuildNet, researchers and engineers can comfortably implement large-scale heterogeneous co-simulations from within their familiar scientific computing environments and languages such as Matlab and Python.
</p>
</div>
</div>


<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8"><span class="section-number-2">2</span> Installation</h2>
<div class="outline-text-2" id="text-2">
<p>
With the Docker-based distribution, it is quick and easy to start using OpenBuildNet.
It is also easy to deploy an OpenBuildNet simulation onto any computers running major operating systems such as Linux, Windows, and Mac OS, or onto a cloud computing service such as the Amazon Elastic Compute Cloud (EC2).
</p>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">2.1</span> Prerequisites</h3>
<div class="outline-text-3" id="text-2-1">
<p>
We will assume that the user is familiar with the Docker technology, understands the terms <i>container</i> and <i>image</i>, and knows how to run and manage Docker containers.
If these sound unfamiliar to you, it is necessary to get acquainted with Docker by following the introduction and tutorial on the Docker <a href="http://www.docker.com/">website</a>.
The user must also be comfortable with using the terminal and writing and running commands at the terminal prompt.
In this tutorial we will demonstrate the steps in a Unix-like environment (such as Linux and Mac OS), however it is straightforward to translate the commands into Windows.
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">2.2</span> Docker installation</h3>
<div class="outline-text-3" id="text-2-2">
<p>
A recent version of Docker must be installed on any computer that needs to run the Docker-based distribution of OpenBuildNet.
Follow the instructions on the Docker <a href="http://www.docker.com/">website</a> to install Docker on your system.
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">2.3</span> Pull the Docker images of OpenBuildNet</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The Docker-based distribution of OpenBuildNet consists of several pre-built images.
Each image targets specific uses.
This is to keep the size of the packages small because a complete OpenBuildNet package for all language interfaces and all applications (e.g., EnergyPlus) will be huge.
This also aligns with the layer-based architecture of Docker images.
Based on the need of the user, appropriate images should be pulled to the user's system.
The <a href="#orgheadline4">Appendix</a> lists all currently available Docker images for OpenBuildNet.
</p>

<p>
In this tutorial, we will need the base image and the Python interface, hence we will pull these two images from the Docker hub by executing the following two commands in the terminal.
</p>
<div class="org-src-container">

<pre class="src src-sh">$ docker pull nxtruong/obnbase
$ docker pull nxtruong/obnpy:2.7
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">2.4</span> MQTT Broker</h3>
<div class="outline-text-3" id="text-2-4">
<p>
OpenBuildNet requires a messaging framework for the communication between nodes.
Currently, only MQTT is supported by the Docker-based distribution.
An MQTT broker is therefore needed to be available and accessible by all computers running the simulation.
For the purpose of this tutorial, a local MQTT broker running on the same computer will suffice.
However, for distributed simulations running on multiple computers, a broker running on the local network, or a public broker on the Internet, is necessary.
If you already have an MQTT broker available (let us call the complete IP address of the broker as <code>MQTTBROKER</code>), you can skip the rest of this section.
</p>

<p>
There are several options to make an MQTT broker available for this tutorial.
</p>
<ol class="org-ol">
<li>Use a public MQTT broker on the Internet, for example: <code>tcp://test.mosquitto.org:1883</code>.  This is the easiest way but also the slowest and most unreliable way because the public broker is usually overloaded.  Use this only for testing, not for final deployment and simulation runs.</li>
<li>Run a dedicated MQTT broker on the local network.  This requires the installation of an MQTT broker such as <a href="http://mosquitto.org/">Mosquitto</a> on a local computer which can be accessed from other computers on the network.  On Mac, one can use Homebrew; on Linux, mosquitto is available on most official repositories (Debian, Ubuntu, etc.); on Windows, a binary installation is provided on Mosquitto's website.  This is the fastest and most reliable option.</li>
<li>The OpenBuildNet base image includes Mosquitto.  One can start the broker in a container and expose the MQTT port so that other computers can access it.  If all nodes run on the same machine, a default bridge network between the containers can be used and the MQTT port does not need to be exposed.  This option does not require any installation, is reliable, but slower than the previous option because of the Docker's network emulation.</li>
</ol>


<p>
In any case, we will use <code>MQTTBROKER</code> to denote the complete IP address of the MQTT broker.
The next subsection details the steps to start the built-in Mosquitto broker in the OpenBuildNet base image (the last option above).
</p>
</div>

<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6"><span class="section-number-4">2.4.1</span> Using the built-in MQTT broker</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li><p>
Open a terminal window and run the following command:
</p>
<div class="org-src-container">

<pre class="src src-shell">$ docker run -d --name mqttserver nxtruong/obnbase start_mqttserver
</pre>
</div>
<p>
This starts an MQTT broker in a container named <i>mqttserver</i> as a daemon (service).  The prompt will return immediately, however the container is still running in the background.
</p></li>
<li><p>
Obtain the IP of the broker by running the following command in the terminal:
</p>
<div class="org-src-container">

<pre class="src src-shell">$ docker inspect --format '{{ .NetworkSettings.IPAddress }}' mqttserver
</pre>
</div>
<p>
This prints out the IP address of the container <i>mqttserver</i>.  Append the IP with the port number <code>:1883</code> and prepend it with <code>tcp://</code> to get <code>MQTTBROKER</code>.  For example: <code>tcp://172.17.0.2:1883</code>.
</p></li>
</ul>


<p>
Because the built-in MQTT broker is running in the background, we should stop it when it is not needed anymore.
In any terminal window:
</p>
<div class="org-src-container">

<pre class="src src-shell">$ docker stop mqttserver
$ docker rm mqttserver
</pre>
</div>
<p>
The first command stops the container; the second command deletes the container.
Note that a stopped container still exists and uses disk space in the system, until it is removed.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12"><span class="section-number-2">3</span> Overview of OpenBuildNet Architecture</h2>
<div class="outline-text-2" id="text-3">
<p>
This section briefly describes the architecture and the most important concepts of OpenBuildNet from the users' perspective.  
</p>
</div>


<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">3.1</span> Nodes as the Building Blocks</h3>
<div class="outline-text-3" id="text-3-1">
<p>
A distributed co-simulation in OpenBuildNet is a <i>synchronous simulation distributed to multiple computation nodes</i>.
The nodes run their own local simulations in parallel, which are synchronized and driven by a global clock at discrete time instants.
A global synchronization mechanism is required because nodes, as sub-simulators, often realize dynamical systems with differing sampling rates and computation speed.
This heterogeneity and multi-timescale nature is particularly typical in the target applications of OpenBuildNet in large-scale energy systems.
</p>

<p>
OpenBuildNet considers the node model illustrated in Figure&nbsp;<a href="#fig:node-model">fig:node-model</a>.
<i>Nodes exchange data with other nodes through ports.</i>
The ports of a node represent its abstract interface to the external environment.
A <i>physical port</i> is a port whose data exchanges are synchronized and strictly managed by the global clock.
As a result, a physical port is either an input or an output exclusively.
In contrast, a <i>data port</i> is not synchronized nor managed by the global clock and can possibly be bidirectional.
Each node and port must have a unique valid identifier, which is a sequence of alphanumeric and the underscore (``_'') characters and may only begin with a letter.
For example, input port <code>i1</code> in Figure&nbsp;<a href="#fig:node-model">fig:node-model</a> is uniquely identified by <code>Node/i1</code>.
</p>

<p>
Because in practice a node may consist of multiple subsystems, it is functionally divided into <i>computation blocks</i> (or <i>blocks</i> for short).
For instance, a building node may simulate both the fast electrical system dynamics and the slow thermal dynamics as two blocks.
A block is essentially a computation unit that may read certain inputs and may compute the values of certain outputs of the node containing it.
This computation is triggered either periodically at a sampling time associated with the block, or non-periodically by requests during run-time, or both.
Each block must have a non-negative sampling time.
The blocks of a node may have different sampling times.
For example, the node illustrated in Figure&nbsp;<a href="#fig:node-model">fig:node-model</a> has two periodic blocks  and a non-periodic block (\(T=0\)).
Note that in this case, block 3 can only be triggered by non-periodic execution requests.
</p>


<div id="orgparagraph1" class="figure">
<p><img src="obn_node_model.png" alt="obn_node_model.png" />
</p>
<p><span class="figure-number">Figure 1:</span> Model of a node in OpenBuildNet with physical input (output) ports depicted on the left (right) and a data port.  Blocks 1 and 2 are executed every 10 minutes and 30 seconds respectively, block 3 is non-periodic.</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">3.2</span> Distributed Network of Nodes</h3>
<div class="outline-text-3" id="text-3-2">
<p>
A simulation system is therefore a network of nodes connected in a certain topology.
In OpenBuildNet a system node, called the <i>System Management Node</i> (SMN), synchronizes the computation of all other nodes and drives the entire simulation.
As its name suggests, it also manages the entire node network besides running the simulation, e.g., adding nodes to the network and handling system errors.
Every node must connect to and communicate with the SMN in order to participate in the co-simulation. 
This architecture is illustrated in Figure&nbsp;<a href="#fig:node-network">fig:node-network</a>.
</p>

<p>
Nodes can be distributed across multiple computers over a communication network (possibly the Internet).
Furthermore, nodes exchange data with each other through their ports and direct peer-to-peer links, i.e., their communications are not routed through the SMN.
This decentralized architecture reduces the communication overhead and helps OpenBuildNet scale up without difficulty.
</p>


<div id="orgparagraph2" class="figure">
<p><img src="obn_network.png" alt="obn_network.png" />
</p>
<p><span class="figure-number">Figure 2:</span> OpenBuildNet network of nodes:  the SMN manages the entire network and coordinates the co-simulation through system communication connections with the nodes (dashed lines).  Nodes communicate directly with each other through their ports and peer-to-peer communication links (solid lines).\vspace{-12pt}</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">3.3</span> Execution and Synchronization</h3>
<div class="outline-text-3" id="text-3-3">
<p>
The execution of a block of a node is split into two stages.
In the first stage, called <i>output update</i>, the block computes and sends out its outputs.
This computation may depend directly on the current values of certain inputs; in that case the block is said to have direct feedthrough from those inputs.
In the second stage, called <i>state update</i>, the block updates its internal states.
</p>

<p>
<i>OpenBuildNet blocks are loosely coupled and only their boundary states are synchronized during the <b>output update</b> stage at discrete-time steps, by exchanging data through their input and output ports.</i>
This synchronization mechanism is controlled by the SMN via system messages.
The interdependencies between blocks determined by their direct feedthrough properties and the system topology define a partial order between them at any time instant. 
The SMN enforces the relative order between blocks by issuing system messages in a precise order decided by a graph-based algorithm.
It also detects <i>algebraic loops</i>, situations in which two blocks have circular dependency between them and their synchronization cannot be resolved.
Blocks that have no relative order between them can be executed simultaneously and hence enjoy the computational speed-up benefit of distributed computation.
</p>



<p>
Details on the synchronization mechanism of OpenBuildNet can be found in the technical documents on our website.
</p>
</div>
</div>
</div>



<div id="outline-container-orgheadline25" class="outline-2">
<h2 id="orgheadline25"><span class="section-number-2">4</span> Tutorial: Control System Simulation</h2>
<div class="outline-text-2" id="text-4">
<p>
In this tutorial, we will develop an OpenBuildNet simulation of a control system in Python.
The tutorial illustrates the most important and commonly used concepts and features in implementing OpenBuildNet nodes and simulations.
</p>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">4.1</span> The control system</h3>
<div class="outline-text-3" id="text-4-1">
<p>
We will implement a control system depicted in Figure&nbsp;<a href="#fig:control-system">fig:control-system</a>.
This is a simple feedback control system of a DC motor model.
Note that the focus of this tutorial is on the OpenBuildNet simulation implementation, not on the control design of the system.
</p>


<div id="orgparagraph3" class="figure">
<p><img src="controlsystem.png" alt="controlsystem.png" />
</p>
<p><span class="figure-number">Figure 3:</span> Block diagram of the control system in the tutorial.</p>
</div>

<p>
The system consists of three nodes: a motor node (the plant), a setpoint node, and a controller node.
</p>
<ul class="org-ul">
<li><b>Setpoint node</b>: this node sets the velocity setpoint.  It has a single output <code>sp</code> which is the setpoint value, and no input.  It changes the setpoint randomly every 4 seconds, therefore its sampling time is 4 seconds.</li>
<li><b>Motor node</b>: this node implements the motor's dynamics.  It has one input <code>vol</code> which is the input voltage and one output <code>v</code> which is the velocity.  The motor's discrete-time dynamics are given by the state-space equations \(x_m(t+1) = A_m x_m(t) + B_m vol(t)\) and \(v(t) = C_m x_m(t)\), where \(x_m \in \mathbb{R}^2\) is the motor's state vector,
\[ A_m = \begin{bmatrix} 1.511 & -0.5488 \\ 1 & 0 \end{bmatrix}, \quad
     B_m = \begin{bmatrix} 0.0625 \\ 0 \end{bmatrix}, \quad
     C_m = \begin{bmatrix} 0.03294 & 0.02697 \end{bmatrix} \]
and with sampling time of 0.1 second.</li>
<li><b>Controller node</b>: this node implements the controller.  It has two inputs: <code>sp</code> receives the setpoint from the Setpoint node and <code>v</code> receives the velocity feedback measurement from the Motor node.  It produces one output: <code>u</code> is the control command to the motor in the form of the input voltage.  The controller implements the discrete-time equations \(x_c(t+1) = A_c x_c(t) + B_c (sp(t) - v(t))\) and \(u(t) = C_c x_c(t)\) where \(x_c \in \mathbb{R}^3\) is the controller's internal state vector, and
\[ A_c = \begin{bmatrix} -0.82 & 1.0 & 0.82 \\ 1 & 0 & 0 \\ 0 & 1 & 0 \end{bmatrix}, \quad
     B_c = \begin{bmatrix} 32 \\ 0 \\ 0 \end{bmatrix}, \quad
     C_c = \begin{bmatrix} 12.62 & -19.75 & 7.625 \end{bmatrix} \]
The sampling time is also 0.1 second.</li>
</ul>
</div>
</div>


<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">4.2</span> Design of the OpenBuildNet simulation</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The system will consist of three nodes as described above and in Figure&nbsp;<a href="#fig:control-system">fig:control-system</a>.
The inputs and outputs of each node are also illustrated in the figure; we will use the same names for the ports.
In this system, all ports send and receive scalar values.
Each node implements a single computation block.
Note the difference in the sampling times between the setpoint node and the other nodes.
</p>

<p>
It is worth noting that there is no direct feedthrough in the controller and motor nodes.
Take the controller node for example.
Its output <code>u</code> solely depends on the controller's state \(x_c\) but not directly on the inputs <code>sp</code> and <code>v</code>, as evident from the equation \(u(t) = C_c x_c(t)\).
However, for the sake of illustration, we will impose that there are direct feedthroughs from both <code>sp</code> and <code>v</code> inputs to the output <code>u</code>.
</p>
</div>
</div>


<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">4.3</span> The setpoint node</h3>
<div class="outline-text-3" id="text-4-3">
<p>
The setpoint node is the simplest one in this example.
We will implement it in Python, using a <i>scripting style</i> which constructs an <code>OBNNode</code> object, creates ports on this node object, then assigns callbacks to various events of the node and runs the simulation of the node.
The complete Python code is in the file <code>nodesetpoint.py</code>.
Below is the step-by-step explanation of the code snippets.
</p>

<p>
We first import the necessary libraries.
</p>
<div class="org-src-container">

<pre class="src src-python">from __future__ import division, print_function
import numpy as np
import sys
from obnpy.obnnode import *
</pre>
</div>

<p>
We then define the variables for the node object and the current setpoint value.
</p>
<div class="org-src-container">

<pre class="src src-python">node = None                     # This will be the node object
setpoint = 0.0                  # The current setpoint value
</pre>
</div>

<p>
Two callbacks are then defined for the node:
</p>
<ul class="org-ul">
<li>The <i>initialization</i> event is triggered only once when the node is initialized at the beginning of the simulation.  The function <code>initNode</code> is the callback for this event, which simply initializes <code>setpoint</code> to 0.</li>
<li>The <i>block output</i> event is triggered whenever the outputs of a specific computation block need to be computed.  Note that output ports with updated values will be sent out automatically after the event, so it is not necessary to explicitly send them over the network.  In its output callback <code>outputSetpoint</code>, the node will randomly choose a new setpoint value between -100 and 100, then set the output port <code>sp</code> to this value.  The dictionary property <code>output_ports</code> of a node object returns a port object, on which the method <code>set</code> is called to set the port's value.</li>
</ul>


<div class="org-src-container">

<pre class="src src-python">def initNode():                 # Init callback
    global setpoint
    setpoint = 0.0              # Reset the setpoint value

def outputSetpoint():           # Change and send the setpoint
    global setpoint, node
    setpoint = np.random.randint(-100, 101) / 10.0
    node.output_ports["sp"].set(setpoint)
</pre>
</div>

<p>
The main function is to construct and run the node.
We allow a command-line argument to set the MQTT server address, which defaults to a local host.
</p>
<div class="org-src-container">

<pre class="src src-python">def main():
    if len(sys.argv) &lt; 2:
        server = 'tcp://localhost:1883'
    else:
        server = sys.argv[1]
</pre>
</div>

<p>
The node object is then created with <code class="src src-python">OBNNode(name,workspace,server)</code> where <code>name</code> is the node's name ("sp" for this node), <code>workspace</code> is the workspace name (more on this below), and <code>server</code> is the MQTT server address.
</p>
<div class="org-src-container">

<pre class="src src-python">    global node
    node = OBNNode("sp", "test2", server) # Create a node
</pre>
</div>
<p>
OpenBuildNet allows multiple simulations to run concurrently, which are distinguished by their names (or workspace names).
Even if a single simulation is run, it is generally a good idea to give it a name.
The <code>workspace</code> argument above sets the name of the workspace / simulation in which this node will run.
It is possible to use an empty string as the workspace name.
</p>

<p>
Next, an output port named <code>sp</code> is created on this node, whose type is a <code>double scalar</code> (i.e., a real number).
The other options for the container type are "vector", "matrix", and "binary" (any binary data), while the other data types include "bool", "int32", "int64", etc.
</p>
<div class="org-src-container">

<pre class="src src-python">    node.create_output("sp", "scalar", "double") # The setpoint output
</pre>
</div>

<p>
The initialization callback is then assigned.
We also assign a callback for the <i>termination</i> event, which is triggered when the simulation is terminated.
In this case, a simple lambda function is used as the callback.
</p>
<div class="org-src-container">

<pre class="src src-python">    node.on_init(initNode)
    node.on_term(lambda: print("Setpoint node terminated."))
</pre>
</div>

<p>
As mentioned earlier, a node may contain multiple computation blocks, each of them must have a unique identification number.
Currently, the eligible range for block IDs is from 0 to 63.
Here, there is only one block, with ID = 0.
The function <code>outputSetpoint</code> defined earlier is set to be the <i>output</i> callback for this block.
</p>
<div class="org-src-container">

<pre class="src src-python">    MAINBLOCK = 0
    node.on_block_output(outputSetpoint, MAINBLOCK)
</pre>
</div>
<p>
All methods for assigning callbacks accept additional arguments after the required ones, which will be given to the callback functions as <i>user arguments</i>.
For example, had the above statement be
</p>
<div class="org-src-container">

<pre class="src src-python">    node.on_block_output(outputSetpoint, MAINBLOCK, "user args")
</pre>
</div>
<p>
then the callback function would have been called as <code class="src src-python">outputSetpoint("user args")</code>.
</p>

<p>
Finally, the node is run, ready to join the overall simulation.
A timeout value in seconds can be given to the <code>run</code> method, which sets the duration for which the node will wait during its interactions with OpenBuildNet before it times out.
The default timeout value of \(-1\) tells the node to never time out.
It is a good idea to set a finite timeout value just in case there is an issue with the communication network or with OpenBuildNet.
However, this timeout value must be long enough to account for possible network latencies and the computation time of the other blocks.
</p>
<div class="org-src-container">

<pre class="src src-python">    print("Ready to run the setpoint node; please start all other nodes ...")
    status = node.run(60)
    print("Simulation stopped with status = {}".format(status))
</pre>
</div>

<p>
The <code>run</code> method returns a status code.
A status code of 2 means the simulation was successful.
Other values have different meanings (e.g., the node has timed out).
</p>
</div>
</div>


<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">4.4</span> The plant node</h3>
<div class="outline-text-3" id="text-4-4">
<p>
The plant node is more complex than the setpoint node as it has both input and output ports, internal states, and more complex computations.
For complex nodes, it is recommended to subclass <code>OBNNode</code> to encapsulate the internal data and properties of the node object, rather than relying on global variables.
This is illustrated in the implementation of the plant node, whose code can be found in the file <code>nodemotor.py</code>.
The definition of the class <code>Motor</code> is reproduced below, which is similar to the code of the setpoint node.
The main difference is that the callbacks are wrapped in a subclass and the node's construction is in the class' constructor.
</p>
<div class="org-src-container">

<pre class="src src-python">class Motor(OBNNode):
    """Node that implements a DC motor model."""
    def __init__(self, workspace, server):
        OBNNode.__init__(self, "motor", workspace, server)

        self.create_input("vol", "scalar", "double") # Create voltage input
        self.create_output("v", "scalar", "double")  # Create velocity output

        MAINBLOCK = 0                   # There is only one block in this node (the motor's dynamics)
        self.on_init(self.initCallback) # assign callback to initialize the node
        self.on_term(lambda: print("Motor node terminated.")) # simple callback for node's termination
        self.on_block_output(self.motorOutput, MAINBLOCK)     # callback to send output
        self.on_block_state(self.updateState, MAINBLOCK)      # callback to update the motor's states

        # Initialize the system's matrices
        self.A = np.array([(1.511, -0.5488), (1.0, 0.0)])
        self.C = np.array([(0.03294, 0.02697)])


    def initCallback(self):
        self.x = np.zeros(2) # Reset the state vector
        self.output_ports["v"].set(0.0) # Initialize the output (not necessary)
        print("At {} simulation started.".format(self.sim_time()))

    def motorOutput(self):
        v = np.dot(self.C, self.x)
        self.output_ports["v"].set(v[0]) # Set the output value
        
    
    def updateState(self):
        v = self.input_ports["vol"].get() # Get the input voltage
        self.x = np.dot(self.A, self.x)
        self.x[0] += 0.0625 * v
</pre>
</div>


<p>
It is important to highlight two details in the above code.
</p>
<ul class="org-ul">
<li>To access an input port on a node, use the property <code>input_ports</code>, for example <code class="src src-python">self.input_ports["vol"]</code>.  To get the current value of a port, use the method <code>get</code>, e.g., <code class="src src-python">self.input_ports["vol"].get()</code>.  For vector and matrix ports, <code>get()</code> returns the data in the appropriate NumPy types.</li>
<li>A computation block also has a <i>state update</i> event, which is <i>triggered at the end of the current simulation time step, after all outputs have been sent and all necessary inputs have been received</i>.  The purpose of this event is to update the internal states of the node with respect to the current input values.  A state update callback should not send output values.  In the case of the plant node, the state update callback is where the motor's states are updated according to the state equation.</li>
</ul>
</div>
</div>


<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17"><span class="section-number-3">4.5</span> The controller node</h3>
<div class="outline-text-3" id="text-4-5">
<p>
The controller node is similar to the plant node because it also implements a state-space model.
Its code is in the file <code>nodectrl.py</code>.
Besides computing the controller's output and states, this node also records its inputs, output, and states at each time step in a file named <code>controller.txt</code>.
Fragments of the logging code can be found in the initialization callback, the state update callback, and the termination callback.
</p>
</div>
</div>


<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23"><span class="section-number-3">4.6</span> The simulation script</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Once all nodes have been implemented, a simulation script is needed to declare the nodes to OpenBuildNet, connect the ports, and run the actual simulation.
The simulation script can be found in the file <code>runsim.oss</code>.
OpenBuildNet currently uses the <a href="http://chaiscript.com/">Chaiscript</a> scripting language, which is similar to Javascript, for its simulation scripts.
There is a plan to switch to Python as the simulation script language.
</p>
</div>

<div id="outline-container-orgheadline18" class="outline-4">
<h4 id="orgheadline18"><span class="section-number-4">4.6.1</span> Simulation setttings</h4>
<div class="outline-text-4" id="text-4-6-1">
<p>
The script first sets some system settings for the simulation, including the workspace name, the atomic time unit (defaults to one microsecond), the final simulation time (defaults to infinite), the communication framework (defaults to MQTT), and the MQTT server address (defaults to the local host).
</p>
<div class="org-src-container">

<pre class="src src-js">workspace("test2");
settings.time_unit(millisecond);
settings.final_time(12*second);

settings.default_comm("mqtt");	// Can change the default communication
settings.MQTT_server((args.count("mqtt")&gt;0)?args.at("mqtt"):"tcp://localhost:1883");
</pre>
</div>
<p>
Note that here the MQTT server address can be specified in the command line when the simulation script is executed.
</p>
</div>
</div>

<div id="outline-container-orgheadline19" class="outline-4">
<h4 id="orgheadline19"><span class="section-number-4">4.6.2</span> Node declarations</h4>
<div class="outline-text-4" id="text-4-6-2">
<p>
Next, each node is declared to OpenBuildNet.  The following details are required or usually provided.
</p>
<ul class="org-ul">
<li><b>name</b> : the unique name of the node.</li>
<li><b>inputs</b> : the list of input ports' names (defaults to empty, ie., no input ports).</li>
<li><b>outputs</b> : the list of output ports' names (defaults to empty, ie., no output ports).</li>
<li><b>blocks</b> : the list of computation blocks. Each block is defined with the following properties.
<ul class="org-ul">
<li><b>sampling</b> : the sampling time of this block.</li>
<li><b>inputs</b> : the list of direct-feedthrough inputs to this block; a logical value can be provided to specify which port has direct-feedthrough (true) and which port does not (false).  This list defaults to empty, i.e., no direct-feedthrough inputs.</li>
<li><b>outputs</b> : the list of output ports of this block, which defaults to empty, i.e., no output.</li>
<li><b>id</b> : the ID number of the block.  If this property is omitted, the blocks' IDs are automatically assigned increasingly from 0.</li>
<li><b>name</b> : optional name of the block.</li>
</ul></li>
</ul>


<p>
For example, the plant / motor node is declared as following.
</p>
<div class="org-src-container">

<pre class="src src-js">var motordef =
	["name" : "motor",
	 "inputs" : ["vol"],
	 "outputs" : ["v"],
	 "blocks" : [["sampling" : 100*millisecond,
				  "outputs" : ["v"]]
				]
	];
var motor = node(motordef);
</pre>
</div>
<p>
Compare this definition to section <a href="#orgheadline13">"The control system"</a> to see how it reflects the properties of the plant node.
The statement <code class="src src-js">var motor = node(motordef)</code> adds the node's declaration to the OpenBuildNet simulation system.
</p>

<p>
The controller and setpoint nodes are declared similarly.
There is one minor difference for the setpoint node.
Because this node does not need the state update event, we declare the node without adding it to OpenBuildNet by (note the <code>false</code> argument, which tells the function not to add the node to OpenBuildNet immediately)
</p>
<div class="org-src-container">

<pre class="src src-js">var sp = node(spdef, false);
</pre>
</div>
<p>
We then specify that the node does not need the state update event <code>updateX</code> and manually add it to OpenBuildNet.
</p>
<div class="org-src-container">

<pre class="src src-js">sp.need_updateX(false);
add_node(sp);
</pre>
</div>

<div class="framed">
<p>
<b>Remark</b>: although it is a good practice to specify whether a node needs the state update event, it is actually not required.  If a node does not define a callback for the event, the event is simply ignored.
</p>

</div>
</div>
</div>


<div id="outline-container-orgheadline20" class="outline-4">
<h4 id="orgheadline20"><span class="section-number-4">4.6.3</span> Port connections</h4>
<div class="outline-text-4" id="text-4-6-3">
<p>
After nodes have been declared, their ports can be connected using the <code>connect</code> function.
The syntax is straightforward: <code class="src src-js">connect(source_node.port("source_port"), target_node.port("target_port"))</code>.
In this example, three connections must be established as following:
</p>
<div class="org-src-container">

<pre class="src src-js">connect(sp.port("sp"), ctrl.port("sp"));
connect(motor.port("v"), ctrl.port("v"));
connect(ctrl.port("u"), motor.port("vol"));
</pre>
</div>

<p>
Consult Figure&nbsp;<a href="#fig:control-system">fig:control-system</a> to justify the above connections.
</p>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-4">
<h4 id="orgheadline21"><span class="section-number-4">4.6.4</span> Model export</h4>
<div class="outline-text-4" id="text-4-6-4">
<p>
Once all nodes and connections have been established, the system configuration may be printed out to the console by the command <code>print_system()</code>.
This is useful to verify the correctness of the system configuration.
</p>

<p>
It is also possible to export a node or the entire system to a graphical representation in the Graphviz's <a href="http://www.graphviz.org/">DOT format</a> or the <a href="http://graphml.graphdrawing.org/">GraphML format</a>.
This is useful for visualizing a node or the system, and for publishing OpenBuildNet models.
</p>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22"><span class="section-number-4">4.6.5</span> Final matter</h4>
<div class="outline-text-4" id="text-4-6-5">
<p>
Once the simulation script reaches its end, the simulation will automatically run unless
</p>
<ul class="org-ul">
<li>a command <code>run_simulation(false)</code> is included in the script; or</li>
<li>the simulation script is executed in the dry-run mode by specifying the option "&#x2013;dry-run" in the command line.</li>
</ul>

<p>
As the nodes in the system may take various amounts of time to start up, it is highly recommended to make the SMN wait for all the nodes to be available before starting the simulation.
This is achieved by the command
</p>
<div class="org-src-container">

<pre class="src src-js">waitfor_all_nodes(30);
</pre>
</div>
<p>
where the number argument is the waiting time in seconds (30 seconds in this case).
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24"><span class="section-number-3">4.7</span> Running the simulation</h3>
<div class="outline-text-3" id="text-4-7">
<p>
Open four terminals, type exactly and run the following commands.
The first three terminals are to run the three nodes, while the last one is for running the OpenBuildNet system node (the SMN).
Note that each node has a timeout of 60 seconds, therefore it is important to start the simulation (the last command) within 60 seconds from the first command.
If you cannot start the nodes quickly enough, you should enter the command in each terminal but do not run them yet.
After all terminals are ready, go through each of them and run the command.
</p>

<p>
In the following, <code>DEMODIR</code> is the <b>absolute path</b> to the directory containing the example code, e.g., <code>/home/user/obntutorial/code</code>, and <code>MQTTBROKER</code> is the IP address of the MQTT broker.
</p>


<ul class="org-ul">
<li><p>
Terminal 1: run the setpoint node
</p>
<div class="org-src-container">

<pre class="src src-shell">$ docker run -it --rm -v DEMODIR:/obnsim nxtruong/obnpy:2.7 python /obnsim/nodesetpoint.py MQTTBROKER
</pre>
</div>
<p>
Check that the node is waiting and no errors are reported.
</p></li>
<li><p>
Terminal 2: run the motor node
</p>
<div class="org-src-container">

<pre class="src src-shell">$ docker run -it --rm -v DEMODIR:/obnsim nxtruong/obnpy:2.7 python /obnsim/nodemotor.py MQTTBROKER
</pre>
</div>
<p>
Check that no errors are reported.
</p></li>
<li><p>
Terminal 3: run the controller node
</p>
<div class="org-src-container">

<pre class="src src-shell">$ docker run -it --rm -v DEMODIR:/obnsim nxtruong/obnpy:2.7 python /obnsim/nodectrl.py MQTTBROKER
</pre>
</div>
<p>
Check that no errors are reported.
</p></li>
<li><p>
Terminal 4: run the simulation script, which runs the simulation
</p>
<div class="org-src-container">

<pre class="src src-shell">$ docker run -it --rm -v DEMODIR:/obnsim nxtruong/obnbase smnchai /obnsim/runsim.oss mqtt=MQTTBROKER
</pre>
</div></li>
</ul>


<p>
Terminal 4 should print the output of the OpenBuildNet server, similar to Figure&nbsp;<a href="#fig:smn-output">fig:smn-output</a>.
A file named <code>controller.txt</code> should be created in <code>DEMODIR</code> which contains the controller's inputs, output, and states at each simulation time step.
Congratulations!
You have run an OpenBuildNet simulation.
</p>


<div id="orgparagraph4" class="figure">
<p><img src="smn_output.png" alt="smn_output.png" />
</p>
<p><span class="figure-number">Figure 4:</span> Output of the OpenBuildNet server running the example's simulation script.</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline26" class="outline-2">
<h2 id="orgheadline26"><span class="section-number-2">5</span> Notes on simulation performance</h2>
<div class="outline-text-2" id="text-5">
<p>
If one has ever used OpenBuildNet natively by compiling the entire OpenBuildNet suite from its source code, they will notice a significant slowdown in the simulation performance of the Docker approach compared to the native approach, especially on the MacOS and Windows platforms.
This section addresses this performance issue.
</p>

<p>
The total running time of an OpenBuildNet simulation is determined by both the computation time of the nodes and the communication time between the nodes.
In our experience, the computation performance of a Docker container is similar to that of the same code running natively, with a negligible loss.
However, the Docker's network performance is significantly worse than the native network performance on the host, from 20 times to hundreds of times slower.
For this reason, the tutorial example may take several seconds to finish on Docker in comparison to several tens of milliseconds on the native host machine.
This is due to the nature of the Docker's network emulation and cannot be resolved easily.
</p>

<p>
On the other hand, the impact of the network performance issue might not be significant in practice, for two reasons:
</p>
<ol class="org-ol">
<li>In large-scale complex simulation systems, the computation time usually dominates the communication time.  Adding a few seconds or minutes to the total simulation time due to the network latency becomes insignificant in these cases.</li>
<li>If a distributed simulation is to be run over the Internet (e.g., on a cloud computing platform), the Internet latency is already large even on native machines.  The Docker's network overhead is insignificant compared to this latency.</li>
</ol>


<p>
In theory, Docker on Linux will have a much smaller network overhead than do Docker on MacOS and Docker on Windows.
However, we have not tested OpenBuildNet on Linux.
</p>
</div>
</div>


<div id="outline-container-orgheadline27" class="outline-2">
<h2 id="orgheadline27"><span class="section-number-2">6</span> Developing nodes with OpenBuildNet Docker images</h2>
<div class="outline-text-2" id="text-6">
<p>
The OpenBuildNet Docker images can also be used to develop OpenBuildNet nodes on a host machine, using the native tools (editors and IDEs) on the host.
For example, to develop a node in Python, one has several options:
</p>

<ol class="org-ol">
<li><p>
Start <code>bash</code> or <code>python</code> or <code>ipython</code> in an interactive container from the image <code>nxtruong/obnpy</code>, then develop the node as in a Linux environment:
</p>
<div class="org-src-container">

<pre class="src src-shell">$ docker run -it -v /path/to/your/code:/obnsim nxtruong/obnpy:2.7 ipython
</pre>
</div>
<p>
Here we mount a directory in the host machine to the container at <code>/obnsim</code>, allowing us to access files in the host machine from the container.
</p></li>

<li><p>
Start an IPython notebook server in a container and access it from the host using an web browser.  This is a great way to develop interactively with Python and OpenBuildNet.
</p>
<div class="org-src-container">

<pre class="src src-shell">$ docker run -it -p 8888:8888 --name ipython -v /path/to/your/code:/obnsim nxtruong/obnpy:2.7 ipython notebook --no-browser --ip=0.0.0.0 --notebook-dir=/obnsim
</pre>
</div>
<p>
The notebook server can be accessed from a web browser on the host machine at the address <code>localhost:8888</code>.
</p></li>
</ol>
</div>
</div>


<div id="outline-container-orgheadline28" class="outline-2">
<h2 id="orgheadline28"><span class="section-number-2">7</span> Customize OpenBuildNet Docker Images</h2>
<div class="outline-text-2" id="text-7">
<p>
The prebuilt OpenBuildNet Docker images contain only the necessary OpenBuildNet binaries and several standard libraries depending on the language.
If one needs additional libraries, they should customize the prebuilt Docker images, using standard Docker commands.
This could be achieved in two ways:
</p>

<ol class="org-ol">
<li>Start <code>bash</code> in a container using the appropriate image, e.g., <code>nxtruong/obnpy</code> for Python or <code>nxtruong/obnjulia</code> for Julia.  Using the appropriate tools to install required packages, e.g., <code>apt-get</code>, <code>pip</code>, Julia's package manager, or manually downloading and compiling source code.  Once the required packages are installed, exit the container and use <code>docker commit</code> to create a new image from the container.  For more information, see <a href="https://docs.docker.com/engine/tutorials/dockerimages/#/updating-and-committing-an-image">Docker's manual</a>.</li>

<li>Alternatively, one can build a new image, based on the appropriate OpenBuildNet Docker image, from a Dockerfile.  For more information, see <a href="https://docs.docker.com/engine/tutorials/dockerimages/#/building-an-image-from-a-dockerfile">Docker's manual</a>.</li>
</ol>
</div>
</div>



<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4"><span class="section-number-2">8</span> Appendix</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29"><span class="section-number-3">8.1</span> Prebuilt Docker images of OpenBuildNet</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Currently, the following images are provided.
</p>
<ul class="org-ul">
<li><b>nxtruong/obnbase</b>: This is the base OpenBuildNet system (server, Chaiscript nodes, MQTT server) which can run the simulation master/server and C/C++ programs built for OpenBuildNet.</li>
<li><b>nxtruong/obnpy</b>: This is the Python interface of OpenBuildNet.  It consists of the base Python system, pip, ipython ipython-notebook, as well as the popular scientific libraries <code>numpy</code>, <code>scipy</code>, <code>matplotlib</code>.  Currently, only Python version 2.7 is available.</li>
<li><b>nxtruong/obnjulia</b>: This the Julia interface of OpenBuildNet.  It consists of the current stable version of Julia (4.6 as of this writing).</li>
<li><b>nxtruong/obnjulia_opt</b>: This is the base Julia image above plus packages for optimization in Julia.  These additional packages include the free solvers and modeling tools available on the <a href="http://www.juliaopt.org/">JuliaOpt website</a>.</li>
<li><b>nxtruong/obneplus</b>: This is a customized EnergyPlus building simulator with built-in support for OpenBuildNet.  Usually the images are built for the two most recent versions of EnergyPlus (v8.4 and v8.5 as of this writing).</li>
<li><b>nxtruong/obndockerbuild</b>: This is the complete C/C++ build system for OpenBuildNet, not needed for deployment but needed for building the OpenBuildNet itself and for building any C/C++ programs for OpenBuildNet.  For deploying OBN nodes and for developing OBN nodes with scripting languages, this image should not be used.</li>
</ul>
</div>
</div>


<div id="outline-container-orgheadline30" class="outline-3">
<h3 id="orgheadline30"><span class="section-number-3">8.2</span> Applications of OpenBuildNet Docker-based distribution</h3>
<div class="outline-text-3" id="text-8-2">
<p>
OBN's Docker images are best used for:
</p>
<ul class="org-ul">
<li>Developing OBN simulations: place the code files in a directory on the host computer, start an appropriate OBN's Docker container and mount the code directory as a volume in the container, use your favorite editor on your host OS to develop the code and the Docker container to test run the code (which are synchronized between the host and the container).  If you use Python or Julia, you can start a Jupyter server in the container and use your web browser to develop OBN nodes interactively in a Jupyter notebook.</li>
<li>Deploying OBN simulations: install and start Docker on the machines you want to deploy to (Docker has tools for creating and managing a swarm of machines), copy the simulation code to each machine (or place it on the Internet), then issue a single command for each node to start the node in an appropriate container.</li>
</ul>


<p>
OBN's Docker images may not be used on embedded computers if Docker is not supported on those platforms.  In those cases, a local installation of OBN is often required.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Truong X. Nghiem</p>
<p class="date">Created: 2016-10-28 Fri 22:38</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
